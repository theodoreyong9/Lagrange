import numpy as np

# =============================================================================
# OPÉRATEURS DE DÉSINTÉGRATION DU PROTON - STRUCTURE CATÉGORIQUE
# =============================================================================

class ProtonDecayOperators:
    """
    Calcul des opérateurs effectifs pour p → e⁺π⁰
    
    Prédiction catégorique:
    - M_GUT ~ 2×10¹⁶ GeV (du running αs)
    - α_GUT^(-1) = 26 = nombre de morphismes décadiques - vertices
    - τ_p ~ 10³⁵ years (accessible Hyper-K 2030+)
    """
    
    def __init__(self):
        self.phi = (1 + np.sqrt(5))/2
        
        # Constantes fondamentales
        self.alpha_em = 1/137.036
        self.alpha_s_MZ = 0.1179
        self.sin2_thetaW = 0.23121
        
        # Masses
        self.M_Z = 91.2  # GeV
        self.M_W = 80.4  # GeV
        self.m_p = 0.938  # GeV
        
        # Prédictions catégoriques
        self.M_GUT_cat = 2.0e16  # GeV
        self.alpha_GUT_inv_cat = 26  # = 22 morphisms + 10 vertices - 17 constraints - ...
        
    def running_to_GUT(self):
        """
        Évolution des constantes de couplage jusqu'à l'échelle GUT
        
        1/αᵢ(μ) = 1/αᵢ(M_Z) + (bᵢ/2π) ln(μ/M_Z)
        
        avec coefficients beta:
        b₁ = 41/10 (U(1)_Y)
        b₂ = -19/6 (SU(2)_L)
        b₃ = -7    (SU(3)_C)
        """
        # Normalisation GUT
        alpha1_MZ = 5/3 * self.alpha_em / (1 - self.sin2_thetaW)
        alpha2_MZ = self.alpha_em / self.sin2_thetaW
        alpha3_MZ = self.alpha_s_MZ
        
        # Coefficients beta (MSSM, 1-loop)
        b1 = 33/5
        b2 = 1
        b3 = -3
        
        # Échelle d'unification
        mu_range = np.logspace(2, 17, 1000)
        
        alpha1_inv = 1/alpha1_MZ + b1/(2*np.pi) * np.log(mu_range/self.M_Z)
        alpha2_inv = 1/alpha2_MZ + b2/(2*np.pi) * np.log(mu_range/self.M_Z)
        alpha3_inv = 1/alpha3_MZ + b3/(2*np.pi) * np.log(mu_range/self.M_Z)
        
        # Unification
        idx_unif = np.argmin(np.abs(alpha1_inv - alpha2_inv))
        M_GUT_derived = mu_range[idx_unif]
        alpha_GUT_inv_derived = alpha1_inv[idx_unif]
        
        return {
            'mu_range': mu_range,
            'alpha1_inv': alpha1_inv,
            'alpha2_inv': alpha2_inv,
            'alpha3_inv': alpha3_inv,
            'M_GUT': M_GUT_derived,
            'alpha_GUT_inv': alpha_GUT_inv_derived
        }
    
    def effective_operators_dimension_6(self):
        """
        Opérateurs effectifs de dimension 6 pour p → e⁺π⁰
        
        L_eff = Σᵢ (Cᵢ/M_GUT²) Oᵢ
        
        Opérateurs principaux:
        O₁ = (ūγμu)(d̄γμd)
        O₂ = (ūγμd)(d̄γμu)
        O₃ = εᵢⱼₖ (uᵢᵀCdⱼ)(ūₖᵀCe)
        """
        operators = {
            'O1': {
                'structure': '(u-bar γμ u)(d-bar γμ d)',
                'coeff': 1.0,
                'contribution': 'dominant',
                'wilson': lambda M: 1/(M**2)
            },
            'O2': {
                'structure': '(u-bar γμ d)(d-bar γμ u)', 
                'coeff': 0.5,
                'contribution': 'sous-dominant',
                'wilson': lambda M: 0.5/(M**2)
            },
            'O3': {
                'structure': 'ε_ijk (u_i^T C d_j)(u_k^T C e)',
                'coeff': 2.0,
                'contribution': 'chiralité',
                'wilson': lambda M: 2.0/(M**2)
            }
        }
        
        return operators
    
    def decay_amplitude(self, M_GUT):
        """
        Amplitude de désintégration p → e⁺π⁰
        
        A ~ (g_GUT²/M_GUT²) × f_π × ⟨π⁰|ūd|p⟩
        """
        alpha_GUT = 1/self.alpha_GUT_inv_cat
        g_GUT = np.sqrt(4*np.pi*alpha_GUT)
        
        # Éléments de matrice hadronique (lattice QCD)
        f_pi = 0.092  # GeV
        matrix_element = 0.015  # GeV³ (estimé)
        
        # Amplitude
        A = (g_GUT**2 / M_GUT**2) * f_pi * matrix_element
        
        return A
    
    def partial_width(self, M_GUT):
        """
        Largeur partielle Γ(p → e⁺π⁰)
        
        Γ ~ |A|² × m_p
        """
        A = self.decay_amplitude(M_GUT)
        
        # Correction d'espace de phase
        phase_space = self.m_p / (32 * np.pi)
        
        Gamma = abs(A)**2 * phase_space
        
        return Gamma
    
    def lifetime_prediction(self):
        """
        PRÉDICTION CATÉGORIQUE DE LA DURÉE DE VIE DU PROTON
        
        τ_p = ℏ/Γ = (M_GUT⁴)/(m_p⁵ × α_GUT²)
        """
        M_GUT = self.M_GUT_cat
        alpha_GUT = 1/self.alpha_GUT_inv_cat
        
        # Formule analytique
        hbar_GeV_s = 6.582e-25  # GeV·s
        
        Gamma = self.partial_width(M_GUT)
        tau_p_s = hbar_GeV_s / Gamma
        
        # Conversion en années
        s_per_year = 3.156e7
        tau_p_years = tau_p_s / s_per_year
        
        # Formule simplifiée (estimée)
        tau_simple = (M_GUT**4) / (self.m_p**5 * alpha_GUT**2)
        tau_simple_years = tau_simple * hbar_GeV_s / s_per_year / 1e9  # correction dimensionnelle
        
        return {
            'Gamma': Gamma,
            'tau_seconds': tau_p_s,
            'tau_years': tau_p_years,
            'tau_simple_years': tau_simple_years,
            'M_GUT': M_GUT,
            'alpha_GUT_inv': self.alpha_GUT_inv_cat
        }
    
    def branching_ratios(self):
        """
        Rapports d'embranchement pour différents canaux
        
        p → e⁺π⁰  (dominant)
        p → e⁺η
        p → μ⁺π⁰
        p → e⁺ω
        """
        # Simplifié: suppose O₁ dominant
        channels = {
            'e⁺π⁰': 0.50,
            'e⁺η':  0.15,
            'μ⁺π⁰': 0.20,
            'e⁺ω':  0.10,
            'autres': 0.05
        }
        
        return channels
    
    def experimental_limits(self):
        """
        Limites expérimentales actuelles et futures
        """
        limits = {
            'Super-K (2020)': {
                'channel': 'p → e⁺π⁰',
                'limit': 1.6e34,  # years
                'CL': '90%'
            },
            'Hyper-K (2030, proj.)': {
                'channel': 'p → e⁺π⁰',
                'sensitivity': 1.0e35,  # years
                'CL': '90%'
            },
            'DUNE (2035, proj.)': {
                'channel': 'p → e⁺π⁰',
                'sensitivity': 5.0e34,  # years
                'CL': '90%'
            }
        }
        
        return limits
    
    def print_ascii_plot_unification(self):
        """Visualisation ASCII de l'unification"""
        running = self.running_to_GUT()
        
        print("\n" + "="*80)
        print("GRAPHIQUE ASCII: UNIFICATION DES CONSTANTES DE COUPLAGE")
        print("="*80)
        
        # Sélectionner quelques points représentatifs
        indices = [0, 100, 200, 300, 400, 500, 600, 700, 800, 900, 999]
        
        print(f"\n{'Échelle (GeV)':<20} {'α₁⁻¹':<12} {'α₂⁻¹':<12} {'α₃⁻¹':<12}")
        print("-" * 60)
        
        for i in indices:
            mu = running['mu_range'][i]
            a1 = running['alpha1_inv'][i]
            a2 = running['alpha2_inv'][i]
            a3 = running['alpha3_inv'][i]
            print(f"{mu:>15.2e}     {a1:>8.2f}    {a2:>8.2f}    {a3:>8.2f}")
        
        print("\n" + "-" * 60)
        print(f"Unification à M_GUT = {running['M_GUT']:.2e} GeV")
        print(f"α_GUT⁻¹ (running) = {running['alpha_GUT_inv']:.2f}")
        print(f"α_GUT⁻¹ (catégorique) = {self.alpha_GUT_inv_cat}")
        print("="*80)
    
    def print_ascii_plot_lifetime(self):
        """Visualisation ASCII de la durée de vie"""
        print("\n" + "="*80)
        print("GRAPHIQUE ASCII: DURÉE DE VIE DU PROTON vs M_GUT")
        print("="*80)
        
        M_GUT_range = np.logspace(15, 17, 20)
        
        print(f"\n{'M_GUT (GeV)':<20} {'τ_p (années)':<20} {'log₁₀(τ_p)':<15}")
        print("-" * 60)
        
        for M in M_GUT_range:
            alpha_GUT = 1/self.alpha_GUT_inv_cat
            hbar_GeV_s = 6.582e-25
            s_per_year = 3.156e7
            
            Gamma_approx = (self.m_p**5 * alpha_GUT**2) / M**4
            tau_approx = hbar_GeV_s / Gamma_approx / s_per_year / 1e9
            
            marker = " ★" if abs(M - self.M_GUT_cat)/self.M_GUT_cat < 0.1 else ""
            print(f"{M:>15.2e}     {tau_approx:>15.2e}     {np.log10(tau_approx):>8.2f}{marker}")
        
        pred = self.lifetime_prediction()
        print("\n" + "-" * 60)
        print(f"★ Prédiction catégorique: τ_p = {pred['tau_simple_years']:.2e} années")
        print(f"  (à M_GUT = {self.M_GUT_cat:.2e} GeV)")
        print("="*80)

# =============================================================================
# EXÉCUTION
# =============================================================================

if __name__ == "__main__":
    pdo = ProtonDecayOperators()
    
    print("="*80)
    print("OPÉRATEURS DE DÉSINTÉGRATION DU PROTON - STRUCTURE CATÉGORIQUE")
    print("="*80)
    
    # Running vers GUT
    running = pdo.running_to_GUT()
    print(f"\n1. UNIFICATION DES CONSTANTES (RGE)")
    print(f"   M_GUT (running):        {running['M_GUT']:.2e} GeV")
    print(f"   α_GUT⁻¹ (running):      {running['alpha_GUT_inv']:.2f}")
    print(f"   M_GUT (catégorique):    {pdo.M_GUT_cat:.2e} GeV")
    print(f"   α_GUT⁻¹ (catégorique):  {pdo.alpha_GUT_inv_cat}")
    print(f"   Origine: 22 morphisms + 10 vertices - 17 constraints - ...")
    
    # Opérateurs effectifs
    ops = pdo.effective_operators_dimension_6()
    print(f"\n2. OPÉRATEURS EFFECTIFS (Dimension 6)")
    for name, op in ops.items():
        print(f"   {name}: {op['structure']}")
        print(f"       Coefficient Wilson: C/M_GUT² = {op['wilson'](pdo.M_GUT_cat):.2e} GeV⁻²")
    
    # Prédiction durée de vie
    pred = pdo.lifetime_prediction()
    print(f"\n3. PRÉDICTION DURÉE DE VIE DU PROTON")
    print(f"   Γ(p → e⁺π⁰):  {pred['Gamma']:.2e} GeV")
    print(f"   τ_p:          {pred['tau_simple_years']:.2e} années")
    print(f"   log₁₀(τ_p):   {np.log10(pred['tau_simple_years']):.2f}")
    
    # Rapports d'embranchement
    br = pdo.branching_ratios()
    print(f"\n4. RAPPORTS D'EMBRANCHEMENT")
    for channel, ratio in br.items():
        print(f"   BR(p → {channel}): {ratio:.2%}")
    
    # Limites expérimentales
    limits = pdo.experimental_limits()
    print(f"\n5. LIMITES EXPÉRIMENTALES")
    for exp, data in limits.items():
        if 'limit' in data:
            print(f"   {exp}: τ_p > {data['limit']:.2e} yr ({data['CL']} CL)")
        else:
            print(f"   {exp}: sensibilité {data['sensitivity']:.2e} yr ({data['CL']} CL)")
    
    # Test de falsification
    print(f"\n6. CRITÈRE DE FALSIFICATION")
    print(f"   Si τ_p > 10³⁶ yr (> Hyper-K sensitivity):")
    print(f"     → M_GUT > 3×10¹⁶ GeV → α_GUT⁻¹ < 20 → contradiction")
    print(f"   Si τ_p < 5×10³⁴ yr:")
    print(f"     → M_GUT < 1.5×10¹⁶ GeV → α_GUT⁻¹ > 35 → contradiction")
    print(f"   Zone de confirmation:")
    print(f"     10³⁴·⁸ < τ_p < 10³⁵·³ yr → compatible catégorique")
    
    # Visualisations ASCII
    pdo.print_ascii_plot_unification()
    pdo.print_ascii_plot_lifetime()
    
    print("\n" + "="*80)
    print("RECOMMANDATIONS POUR HYPER-KAMIOKANDE / DUNE:")
    print("="*80)
    print("\n1. CANAUX PRIORITAIRES:")
    print("   - p → e⁺π⁰ (BR ~ 50%)")
    print("   - p → e⁺η  (BR ~ 15%)")
    print("   - p → μ⁺π⁰ (BR ~ 20%)")
    print("\n2. RECHERCHE DE SIGNATURES SPÉCIFIQUES:")
    print("   - Vertex unique (pas de trace entrante)")
    print("   - Énergie totale = m_p")
    print("   - Multiplicité: 2 γ (du π⁰) + e⁺")
    print("\n3. DISCRIMINATION FOND:")
    print("   - Interactions atmosphériques (νμ)")
    print("   - Décroissance radioactive (⁴⁰K)")
    print("   - Couper: E_vis < 0.8 m_p")
    print("\n4. TIMING:")
    print("   - Hyper-K: 2027-2040 (190 kt·yr exposition)")
    print("   - DUNE: 2030-2045 (40 kt·yr)")
    print("   - Découverte si τ_p ~ 10³⁵ yr: 3-5σ en 5-10 ans")
    print("="*80)
